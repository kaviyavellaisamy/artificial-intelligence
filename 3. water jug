from collections import deque

# Define the capacities
jug1_capacity = 4
jug2_capacity = 3
goal = 2

# To store visited states
visited = set()

# To store the path
path = []

def is_goal(state):
    return state[0] == goal or state[1] == goal

def get_next_states(current):
    (a, b) = current
    next_states = []

    # Fill Jug1
    next_states.append((jug1_capacity, b))
    # Fill Jug2
    next_states.append((a, jug2_capacity))
    # Empty Jug1
    next_states.append((0, b))
    # Empty Jug2
    next_states.append((a, 0))
    # Pour Jug1 -> Jug2
    pour = min(a, jug2_capacity - b)
    next_states.append((a - pour, b + pour))
    # Pour Jug2 -> Jug1
    pour = min(b, jug1_capacity - a)
    next_states.append((a + pour, b - pour))

    return next_states

def bfs():
    queue = deque()
    queue.append((0, 0))  # Start with both jugs empty
    visited.add((0, 0))
    parent = dict()
    parent[(0, 0)] = None

    while queue:
        current = queue.popleft()
        if is_goal(current):
            # Trace path back
            while current:
                path.append(current)
                current = parent[current]
            path.reverse()
            return True

        for state in get_next_states(current):
            if state not in visited:
                visited.add(state)
                parent[state] = current
                queue.append(state)

    return False

# Run the BFS
if bfs():
    print("Steps to reach the goal:")
    for step in path:
        print(f"Jug1: {step[0]}L, Jug2: {step[1]}L")
else:
    print("No solution found.")
